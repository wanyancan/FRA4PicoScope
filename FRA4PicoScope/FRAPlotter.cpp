//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Frequency Response Analyzer for PicoScope
//
// Copyright (c) 2014 by Aaron Hexamer
//
// This file is part of the Frequency Response Analyzer for PicoScope program.
//
// Frequency Response Analyzer for PicoScope is free software: you can 
// redistribute it and/or modify it under the terms of the GNU General Public 
// License as published by the Free Software Foundation, either version 3 of 
// the License, or (at your option) any later version.
//
// Frequency Response Analyzer for PicoScope is distributed in the hope that 
// it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Frequency Response Analyzer for PicoScope.  If not, see <http://www.gnu.org/licenses/>.
//
// Module: FRAPlotter.cpp
//
//////////////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
// Suppress a warning generated by use of std::copy by Boost string trimming function
#define _SCL_SECURE_NO_WARNINGS
#include "FRAPlotter.h"
#include "plplot.h"
#include <cmath>
#include <algorithm>
#include <sstream>
#include <boost/math/special_functions/sign.hpp>
using namespace boost::math;
#include <boost/algorithm/string.hpp>
using namespace boost;
#include <Wincodec.h>

// Use of strnpy in this program is safe, since it is bounded and explicitly null terminated
#if defined(_MSC_VER)
#pragma warning(disable: 4996)
#endif

// MSVC does not define these standard library functions
#if defined(_MSC_VER)
#define isnan(x) _isnan(x)
#define isinf(x) (!_finite(x))
#endif

// These are functions that are made public in PLPlot but are not defined in the plplot header.  We need them to
// support the master grids concept and enhanced precision labeling for the y-axis.
extern "C" 
{
    void label_box_custom( const char *xopt, PLINT n_xticks, const PLFLT *xticks, const char *yopt, PLINT n_yticks, const PLFLT *yticks );
    void pldtik( PLFLT vmin, PLFLT vmax, PLFLT *tick, PLINT *nsubt, PLBOOL ld );
    void pldprec( PLFLT vmin, PLFLT vmax, PLFLT tick, PLINT lf, PLINT *mode, PLINT *prec, PLINT digmax, PLINT *scale );
    void plP_xgvpw( PLFLT *p_xmin, PLFLT *p_xmax, PLFLT *p_ymin, PLFLT *p_ymax );
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name: SafeRelease
//
// Purpose: Release Com resource if it is allocated
//
// Parameters: [in] ppT - Pointer to the object to release
//
// Notes: 
//
///////////////////////////////////////////////////////////////////////////////////////////////////

template <class T> void SafeRelease(T **ppT)
{
    if (*ppT)
    {
        (*ppT)->Release();
        *ppT = NULL;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name: FRAPlotter::FRAPlotter
//
// Purpose: Constructor
//
// Parameters: [in] width - Width of the plot
//             [in] height - Height of the plot
//
// Notes: 
//
///////////////////////////////////////////////////////////////////////////////////////////////////

FRAPlotter::FRAPlotter( uint16_t width, uint16_t height )
{
    plotWidth = width;
    plotHeight = height;
    plotBmBuffer.resize(plotWidth*plotHeight*bytesPerPixel);
    plotDataAvailable = false;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name: FRAPlotter::Initialize
//
// Purpose: Initialize the FRAPlotter object, creating all the appropriate thread structures to 
//          support the services it provides.
//
// Parameters:
//
// Notes: 
//
///////////////////////////////////////////////////////////////////////////////////////////////////

bool FRAPlotter::Initialize(void)
{
    hFraPlotterExecuteCommandEvent = CreateEventW( NULL, false, false, L"ExecutePlotterCommand" );

    if ((HANDLE)NULL == hFraPlotterExecuteCommandEvent)
    {
        return false;
    }

    if( !ResetEvent( hFraPlotterExecuteCommandEvent ) )
    {
        return false;
    }

    hFraPlotterCommandCompleteEvent = CreateEventW( NULL, false, false, L"PlotterCommandComplete" );

    if ((HANDLE)NULL == hFraPlotterCommandCompleteEvent)
    {
        return false;
    }

    if( !ResetEvent( hFraPlotterCommandCompleteEvent ) )
    {
        return false;
    }

    hFraPlotterWorkerThread = CreateThread( NULL, 0, WorkerThread, this, 0, NULL );

    if (0 != GetLastError())
    {
        return false;
    }

    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name: FRAPlotter::~FRAPlotter
//
// Purpose: Destructor
//
// Parameters: N/A
//
// Notes: 
//
///////////////////////////////////////////////////////////////////////////////////////////////////

FRAPlotter::~FRAPlotter(void)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name: FRAPlotter::PlotFRA
//
// Purpose: Plots the FRA data to an internal buffer
//
// Parameters: [in] freqs - Frequencies at which the FRA was executed
//             [in] gains - Gains from the FRA execution
//             [in] phases - Phases from the FRA execution
//             [in] N - Number of data points in the arrays supplied
//             [in] freqAxisScale - a tuple where the first element is whether to autoscale,
//                                  and if false, the second and third are the min and max values
//             [in] gainAxisScale - a tuple where the first element is whether to autoscale,
//                                  and if false, the second and third are the min and max values
//             [in] phaseAxisScale - a tuple where the first element is whether to autoscale,
//                                   and if false, the second and third are the min and max values
//             [in] freqAxisIntervals - a tuple where the first two elements are the major and 
//                                      minor intervals, and the next two elements indicate
//                                      whether to draw grids
//             [in] gainAxisIntervals - a tuple where the first two elements are the major and 
//                                      minor intervals, and the next two elements indicate
//                                      whether to draw grids
//             [in] phaseAxisIntervals - a tuple where the first two elements are the major and 
//                                       minor intervals, and the next two elements indicate
//                                       whether to draw grids
//
// Notes: Can pass N = 0, which means use last data passed; Throws a runtime_error if N = 0, 
//           but no data is available.
//        Use of 0.0 for intervals results in PLplot automatically calculating an interval.
//        Can throw a runtime_error exception with an error message indicating the PLplot error
//
///////////////////////////////////////////////////////////////////////////////////////////////////

void FRAPlotter::PlotFRA(double freqs[], double gains[], double phases[], int N, 
                         tuple<bool,double,double> freqAxisScale,
                         tuple<bool,double,double> gainAxisScale, 
                         tuple<bool,double,double> phaseAxisScale,
                         tuple<double,uint8_t,bool,bool> freqAxisIntervals,
                         tuple<double,uint8_t,bool,bool> gainAxisIntervals, 
                         tuple<double,uint8_t,bool,bool> phaseAxisIntervals,
                         bool gainMasterIntervals, bool phaseMasterIntervals)
{
    double minGain, maxGain;
    double minPhase, maxPhase;
    double minFreq, maxFreq;
    double delta;
    currentFreqAxisOpts = "bclnst";
    currentGainAxisOpts = "bnostv";
    currentPhaseAxisOpts = "cmostv";

    plotDataAvailable = false; // Will remain false if an exception is thrown

    // Store the plot data
    if (0 != N)
    {
        currentFreqs = vector<double>(freqs, freqs+N);
        currentGains = vector<double>(gains, gains+N);
        currentPhases = vector<double>(phases, phases+N);
    }
    else if (0 == currentFreqs.size())
    {
        throw runtime_error( "Plotting subsystem error: No data to plot" );
    }

    // Compute axis mins and maxes
    if (get<0>(freqAxisScale)) // autoscale is true
    {

        minFreq = *min_element(currentFreqs.begin(), currentFreqs.end());
        maxFreq = *max_element(currentFreqs.begin(), currentFreqs.end());
    }
    else
    {
        minFreq = get<1>(freqAxisScale);
        maxFreq = get<2>(freqAxisScale);
        minFreq = log10(minFreq);
        maxFreq = log10(maxFreq);
        // Check to see if log10 worked.  Use isnan and isinf instead of comparing inputs to 0.0
        if (isnan(minFreq) || isinf(minFreq) || isnan(maxFreq) || isinf(maxFreq))
        {
            // One of the inputs must have been 0.0
            throw runtime_error("Error: Invalid log frequency axis scale");
        }
    }

    if (get<0>(gainAxisScale)) // autoscale is true
    {
        minGain = *min_element(currentGains.begin(),currentGains.end());
        maxGain = *max_element(currentGains.begin(),currentGains.end());

        delta = maxGain - minGain;
        minGain -= 0.1 * delta;
        maxGain += 0.1 * delta;
    }
    else
    {
        minGain = get<1>(gainAxisScale);
        maxGain = get<2>(gainAxisScale);
    }

    if (get<0>(phaseAxisScale)) // autoscale is true
    {
        minPhase = *min_element(currentPhases.begin(),currentPhases.end());
        maxPhase = *max_element(currentPhases.begin(),currentPhases.end());

        delta = maxPhase - minPhase;
        minPhase -= 0.1 * delta;
        maxPhase += 0.1 * delta;
    }
    else
    {
        minPhase = get<1>(phaseAxisScale);
        maxPhase = get<2>(phaseAxisScale);
    }

    // Store the axis values, storing frequency as linear
    currentFreqAxisMin = minFreq;
    currentFreqAxisMax = maxFreq;
    currentGainAxisMin = minGain;
    currentGainAxisMax = maxGain;
    currentPhaseAxisMin = minPhase;
    currentPhaseAxisMax = maxPhase;

    // Set up options for grids
    if (get<2>(freqAxisIntervals))
    {
        currentFreqAxisOpts += "g";
    }
    if (get<3>(freqAxisIntervals))
    {
        currentFreqAxisOpts += "h";
    }
    if (get<2>(gainAxisIntervals))
    {
        currentGainAxisOpts += "g";
    }
    if (get<3>(gainAxisIntervals))
    {
        currentGainAxisOpts += "h";
    }
    if (get<2>(phaseAxisIntervals))
    {
        currentPhaseAxisOpts += "g";
    }
    if (get<3>(phaseAxisIntervals))
    {
        currentPhaseAxisOpts += "h";
    }

    currentFreqAxisMajorTickInterval = get<0>(freqAxisIntervals);
    currentFreqAxisMinorTicksPerMajorInterval = get<1>(freqAxisIntervals);
    currentGainAxisMajorTickInterval = get<0>(gainAxisIntervals);
    currentGainAxisMinorTicksPerMajorInterval = get<1>(gainAxisIntervals);
    currentPhaseAxisMajorTickInterval = get<0>(phaseAxisIntervals);
    currentPhaseAxisMinorTicksPerMajorInterval = get<1>(phaseAxisIntervals);
    currentGainMasterIntervals = gainMasterIntervals;
    currentPhaseMasterIntervals = phaseMasterIntervals;

    PlotFRA();

    // Clear the zoom stack and push the new axis values onto the zoom stack
    while (!zoomStack.empty()) 
    {
        zoomStack.pop();
    }
    zoomStack.push(make_tuple(make_tuple(get<0>(freqAxisScale), currentFreqAxisMin, currentFreqAxisMax), 
                              make_tuple(get<0>(gainAxisScale), currentGainAxisMin, currentGainAxisMax), 
                              make_tuple(get<0>(phaseAxisScale), currentPhaseAxisMin, currentPhaseAxisMax)));

    // Save all current settings
    currentPlotSettings.freqAxisScale = make_tuple( get<0>(freqAxisScale), pow(10.0, currentFreqAxisMin), pow(10.0, currentFreqAxisMax) );
    currentPlotSettings.freqAxisIntervals = freqAxisIntervals;
    currentPlotSettings.gainAxisScale = make_tuple( get<0>(gainAxisScale), currentGainAxisMin, currentGainAxisMax );
    currentPlotSettings.gainAxisIntervals = gainAxisIntervals;
    currentPlotSettings.phaseAxisScale = make_tuple( get<0>(phaseAxisScale), currentPhaseAxisMin, currentPhaseAxisMax );
    currentPlotSettings.phaseAxisIntervals = phaseAxisIntervals;
    currentPlotSettings.gainMasterIntervals = gainMasterIntervals;
    currentPlotSettings.phaseMasterIntervals = phaseMasterIntervals;

    plotDataAvailable = true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name: FRAPlotter::PlotFRA
//
// Purpose: Plots the FRA data to an internal buffer, using PLplot routines
//
// Parameters: None
//
// Notes: Used by other public plotting functions to carry out the lower level work of calling 
//        PLplot routines
//
///////////////////////////////////////////////////////////////////////////////////////////////////

void FRAPlotter::PlotFRA(void)
{
    PLINT digmax, digits;

    for (uint8_t &bufferElem : plotBmBuffer) // range based for from C++11 not available in VS2010
    {
        bufferElem = 230; // Set to a light gray background
    }

    plsdev( "mem" );
    plsmem(plotWidth, plotHeight, plotBmBuffer.data());
    plinit();
    plsexit(HandlePLplotError);

    pladv( 0 );

    // Setup the viewport
    plvpor( viewPortLeftEdge, viewPortRightEdge, viewPortBottomEdge, viewPortTopEdge );

    // Specify the coordinates of the viewport boundaries for gain
    plwind( currentFreqAxisMin, currentFreqAxisMax, currentGainAxisMin, currentGainAxisMax );

    // Set the color of the viewport box
    plcol0( 0 );
    // Setup box and axes for frequency
    plbox( currentFreqAxisOpts.c_str(), currentFreqAxisMajorTickInterval, currentFreqAxisMinorTicksPerMajorInterval, "", 0.0, 0 );

    // Plot axis for gain
    scientific = false;
    yAxisScale = 0;
    if (currentPhaseMasterIntervals)
    {
        PLFLT tmpPhaseAxisMajorTickInterval = 0.0;
        PLINT tmpPhaseAxisMinorTicksPerMajorInterval = 0;
        if (0.0 != currentPhaseAxisMajorTickInterval)
        {
            tmpPhaseAxisMajorTickInterval = currentPhaseAxisMajorTickInterval;
        }
        else
        {
            pldtik( currentPhaseAxisMin, currentPhaseAxisMax, &tmpPhaseAxisMajorTickInterval, &tmpPhaseAxisMinorTicksPerMajorInterval, false );
        }

        vector<PLFLT> customTicks;
        PLFLT scaleFactor = ((currentGainAxisMax-currentGainAxisMin)/(currentPhaseAxisMax-currentPhaseAxisMin));
        PLFLT gainMajorTickInterval = scaleFactor * tmpPhaseAxisMajorTickInterval;
        customTicks.resize( (size_t)((currentPhaseAxisMax-currentPhaseAxisMin)/tmpPhaseAxisMajorTickInterval)+2 );
        if (customTicks.size() != 0)
        {
            // Compute the top tick
            customTicks[0] = currentGainAxisMax - fmod(currentPhaseAxisMax, tmpPhaseAxisMajorTickInterval) * scaleFactor;
            // Compute the rest
            for ( uint32_t i = 1; i < customTicks.size(); i++ )
            {
                customTicks[i] = customTicks[i-1] - gainMajorTickInterval;
            }

            plsyax( 5, 0 );
            plslabelfunc( LabelYAxis, &gainMajorTickInterval );
            widestYAxisLabel = 0;
            label_box_custom( "", 0, NULL, currentGainAxisOpts.c_str(), customTicks.size(), customTicks.data() );
            plsyax( 5, widestYAxisLabel );
        }
        plbox( "", 0.0, 0, "b", 0.0, 0 );  // Need to draw the left side of the box because label_box_custom doesn't
    }
    else
    {
        PLFLT tmpGainAxisMajorTickInterval = 0.0;
        PLINT tmpGainAxisMinorTicksPerMajorInterval = 0;
        if (0.0 != currentGainAxisMajorTickInterval)
        {
            tmpGainAxisMajorTickInterval = currentGainAxisMajorTickInterval;
        }
        else
        {
            pldtik( currentGainAxisMin, currentGainAxisMax, &tmpGainAxisMajorTickInterval, &tmpGainAxisMinorTicksPerMajorInterval, false );
        }
        plsyax( 5, 0 );
        plslabelfunc( LabelYAxis, &tmpGainAxisMajorTickInterval ); 
        plbox( "", 0.0, 0, currentGainAxisOpts.c_str(), currentGainAxisMajorTickInterval, currentGainAxisMinorTicksPerMajorInterval );
    }
    if (scientific)
    {
        LabelYAxisExponent( yAxisScale, "lv" );
    }

    // Set the color of the gain data
    plcol0( 9 );
    // Plot the gain data
    plline( currentFreqs.size(), currentFreqs.data(), currentGains.data() );

    // Start Labeling
    plcol0( 0 );
    plmtex( "b", 3.2, 0.5, 0.5, "Frequency Log(Hz)" );
    plmtex( "t", 2.0, 0.5, 0.5, "Frequency Response Bode Plot" );
    plcol0( 9 );
    
    plgyax( &digmax, &digits );
    plmtex( "l", digits+2, 0.5, 0.5, "Gain (dB)" );

    // Specify the coordinates of the viewport boundaries for phase
    plwind( currentFreqAxisMin, currentFreqAxisMax, currentPhaseAxisMin, currentPhaseAxisMax );
    // Set the color of the viewport box
    plcol0( 0 );
    
    // Plot axis for phase
    scientific = false;
    yAxisScale = 0;
    if (currentGainMasterIntervals)
    {
        PLFLT tmpGainAxisMajorTickInterval = 0.0;
        PLINT tmpGainAxisMinorTicksPerMajorInterval = 0;
        if (0.0 != currentGainAxisMajorTickInterval)
        {
            tmpGainAxisMajorTickInterval = currentGainAxisMajorTickInterval;
        }
        else
        {
            pldtik( currentGainAxisMin, currentGainAxisMax, &tmpGainAxisMajorTickInterval, &tmpGainAxisMinorTicksPerMajorInterval, false );
        }
        vector<PLFLT> customTicks;
        PLFLT scaleFactor = ((currentPhaseAxisMax-currentPhaseAxisMin)/(currentGainAxisMax-currentGainAxisMin));
        PLFLT phaseMajorTickInterval = scaleFactor * tmpGainAxisMajorTickInterval;
        customTicks.resize( (size_t)((currentGainAxisMax-currentGainAxisMin)/tmpGainAxisMajorTickInterval)+2 );
        if (customTicks.size() != 0)
        {
            // Compute the top tick
            customTicks[0] = currentPhaseAxisMax - fmod(currentGainAxisMax, tmpGainAxisMajorTickInterval) * scaleFactor;
            // Compute the rest
            for ( uint32_t i = 1; i < customTicks.size(); i++ )
            {
                customTicks[i] = customTicks[i-1] - phaseMajorTickInterval;
            }
    
            plsyax( 5, 0 );
            plslabelfunc( LabelYAxis, &phaseMajorTickInterval );
            widestYAxisLabel = 0;
            label_box_custom( "", 0, NULL, currentPhaseAxisOpts.c_str(), customTicks.size(), customTicks.data() );
            plsyax( 5, widestYAxisLabel );
        }
        plbox( "", 0.0, 0, "c", 0.0, 0 );  // Need to draw the right side of the box because label_box_custom doesn't
    }
    else
    {
        PLFLT tmpPhaseAxisMajorTickInterval = 0.0;
        PLINT tmpPhaseAxisMinorTicksPerMajorInterval = 0;
        if (0.0 != currentPhaseAxisMajorTickInterval)
        {
            tmpPhaseAxisMajorTickInterval = currentPhaseAxisMajorTickInterval;
        }
        else
        {
            pldtik( currentPhaseAxisMin, currentPhaseAxisMax, &tmpPhaseAxisMajorTickInterval, &tmpPhaseAxisMinorTicksPerMajorInterval, false );
        }
        plsyax( 5, 0 );
        plslabelfunc( LabelYAxis, &tmpPhaseAxisMajorTickInterval ); 
        plbox( "", 0.0, 0, currentPhaseAxisOpts.c_str(), currentPhaseAxisMajorTickInterval, currentPhaseAxisMinorTicksPerMajorInterval );
    }
    if (scientific)
    {
        LabelYAxisExponent( yAxisScale, "rv" );
    }

    // Set the color of the phase data
    plcol1(0.9); // Something near red
    // Plot the phase data
    plline( currentFreqs.size(), currentFreqs.data(), currentPhases.data() );

    // Label phase data
    plcol1(0.9); // Something near red
    plgyax( &digmax, &digits );
    plmtex( "r", digits+2, 0.5, 0.5, "Phase (degrees)" );

    // Close PLplot library
    plend();
}

// Definition of static variables used by custom axis labeling functions
PLINT FRAPlotter::widestYAxisLabel;
bool FRAPlotter::scientific;
PLINT FRAPlotter::yAxisScale;

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name: FRAPlotter::LabelYAxis
//
// Purpose: Serves as a custom axis labeling function as defined by plslabelfunc
//
// Parameters: See PLplot documentation for plslabelfunc
//
// Notes: The main purpose of this function is to get a more enhanced auto-precision 
//        functionality for y axis labels.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
 
extern "C" void FRAPlotter::LabelYAxis(PLINT axis, PLFLT value, char * labelText, PLINT length, PLPointer labelData)
{
    PLFLT hmin, hmax, vmin, vmax, tick;
    PLINT ydigmax, ydigits, mode, prec, scale;
    stringstream labelSS;
    string labelString;

    // Check inputs
    if (axis != PL_Y_AXIS)
    {
        throw runtime_error( "LabelYAxis error: wrong axis" );
    }
    if (!labelData)
    {
        throw runtime_error( "LabelAxis error: tick data pointer is NULL" );
    }
    else
    {
        tick = *((PLFLT*)labelData);
    }
    
    // See whether PLPlot would use scientific mode or not
    plP_xgvpw( &hmin, &hmax, &vmin, &vmax );
    plgyax( &ydigmax, &ydigits );
    pldprec( vmin, vmax, tick, 0, &mode, &prec, ydigmax, &scale );

    // If it would use scientific, scale the value accordingly
    if (mode)
    {
        value /= pow(10.0,scale);
        scientific = true;
        yAxisScale = scale;
    }

    // Output a fixed point value with the most significant digits allowed by digmax
    // Compute most number of digits past the decimal ever possible while still honoring digmax
    prec = ydigmax - 2 - (signbit(value) ? 1 : 0); // 2 is for sign and first digit left of the decimal point
    // Output using stream I/O
    labelSS.precision(prec);
    labelSS << fixed << value;
    labelString = labelSS.str();

    // Smash trailing zeros right of a decimal point, then strip all fractional parts if they cause us not to fit 
    // within digmax.  Arriving at no more than digmax digits, assumes PLPlot has correctly computed scientific 
    // mode such that the whole part fits within digmax
    size_t decimalPointPos;
    if (string::npos != labelString.find("."))
    {
        trim_right_if( labelString, is_any_of("0") );
        // If there's a decimal point remaining on the end, it needs to be stripped too
        trim_right_if( labelString, is_any_of(".") );
    }
    if (string::npos != (decimalPointPos = labelString.find(".")))
    {
        if ((PLINT)decimalPointPos > (ydigmax-2))
        {
            labelString = labelString.substr( 0, decimalPointPos-1 );
        }
    }
    // Finally, correct for possibility of "-0"
    if (0 == labelString.compare("-0"))
    {
        labelString = "0";
    }

    // Copy the string over to PLplot's output parameter
    strncpy( labelText, labelString.c_str(), length );
    labelText[length-1] = '\0';

    // Record widest string since some of the paths this gets called on (e.g. label_box_custom) fail to record it
    widestYAxisLabel = max(widestYAxisLabel, (PLINT)strlen(labelText));

}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name: FRAPlotter::LabelYAxisExponent
//
// Purpose: Labels the exponent of the Y axis
//
// Parameters: [in] scale: power of 10 for the exponent label
//             [in] side: string representing which side (gain is "lv" and phase is "rv")
//
// Notes: This function is necessary because use of custom axis labeling via "o" option and 
//        plslabelfunc will not automatically print the exponent.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

void FRAPlotter::LabelYAxisExponent( PLINT scale, char* side )
{
    stringstream exponentFormatSS;
    exponentFormatSS << "(x10#u" << scale << "#d)";

    plmtex( side, 3.0, 1.07, 0.5, exponentFormatSS.str().c_str() );
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name: FRAPlotter::Zoom
//
// Purpose: Replot the FRA plot with bounds defined by the zoom box
//
// Parameters: [in] plotOriginPoint: upper left screen coordinates (x,y) of the plot viewport
//             [in] plotExtentPoint: lower right screen coordinates (x,y) of the plot viewport
//             [in] zoomOriginPoint: screen coordinates (x,y) of the zoom box
//             [in] zoomExtentPoint: screen coordinates (x,y) of the zoom box
//             [out] return: whether the zoom could be performed
//
// Notes: Cases where zoom is not allowed (and return is false) are: (1) user tried to zoom more 
//        than 10 times, (2) zoom box is totally outside the viewport, (3) the zoom is too great
//        for PLplot to support (i.e. width or height < 1e-6 units)
//
///////////////////////////////////////////////////////////////////////////////////////////////////

bool FRAPlotter::Zoom(tuple<int32_t,int32_t> plotOriginPoint,
                      tuple<int32_t,int32_t> plotExtentPoint,
                      tuple<int32_t,int32_t> zoomOriginPoint,
                      tuple<int32_t,int32_t> zoomExtentPoint)
{
    bool retVal = false;
    plotDataAvailable = false; // Will remain false if an exception is thrown

    if (zoomStack.size() >= 11) // Allow 10 zooms from original
    {
        retVal = false;
    }
    else
    {
        double freqUnitsPerPixel, gainUnitsPerPixel, phaseUnitsPerPixel;
        int32_t zoomXMinPixel, zoomXMaxPixel, zoomYMinPixel, zoomYMaxPixel;
        double newFreqAxisMin, newFreqAxisMax, newGainAxisMin, newGainAxisMax, newPhaseAxisMin, newPhaseAxisMax;
    
        // First, calculate axis units to screen pixel ratios
        freqUnitsPerPixel = (currentFreqAxisMax-currentFreqAxisMin) / ((viewPortRightEdge-viewPortLeftEdge)*(get<0>(plotExtentPoint)-get<0>(plotOriginPoint)));
        gainUnitsPerPixel = (currentGainAxisMax-currentGainAxisMin) / ((viewPortTopEdge-viewPortBottomEdge)*(get<1>(plotExtentPoint)-get<1>(plotOriginPoint)));
        phaseUnitsPerPixel = (currentPhaseAxisMax-currentPhaseAxisMin) / ((viewPortTopEdge-viewPortBottomEdge)*(get<1>(plotExtentPoint)-get<1>(plotOriginPoint)));

        // Zoom origin and extent may be in any of the 4 possible spatial relations to each other, so sort them out here.
        zoomXMinPixel = min(get<0>(zoomOriginPoint),get<0>(zoomExtentPoint));
        zoomXMaxPixel = max(get<0>(zoomOriginPoint),get<0>(zoomExtentPoint));
        zoomYMinPixel = min(get<1>(zoomOriginPoint),get<1>(zoomExtentPoint));
        zoomYMaxPixel = max(get<1>(zoomOriginPoint),get<1>(zoomExtentPoint));

        // Calculate initial values for new axis scales, trying to stay in units with most precision (i.e. don't work in integer pixels)
        // X axis scales are in the same direction as screen coordinates, so scale them from plot origin
        newFreqAxisMin = currentFreqAxisMin + (zoomXMinPixel-get<0>(plotOriginPoint))*freqUnitsPerPixel - viewPortLeftEdge*(get<0>(plotExtentPoint)-get<0>(plotOriginPoint))*freqUnitsPerPixel;
        newFreqAxisMax = currentFreqAxisMin + (zoomXMaxPixel-get<0>(plotOriginPoint))*freqUnitsPerPixel - viewPortLeftEdge*(get<0>(plotExtentPoint)-get<0>(plotOriginPoint))*freqUnitsPerPixel;
        // Y axis scales are in the opposite direction as screen coordinates, so scale them from plot extent
        newGainAxisMin = currentGainAxisMin + (get<1>(plotExtentPoint) - zoomYMaxPixel)*gainUnitsPerPixel - viewPortBottomEdge*(get<1>(plotExtentPoint)-get<1>(plotOriginPoint))*gainUnitsPerPixel;
        newGainAxisMax = currentGainAxisMin + (get<1>(plotExtentPoint) - zoomYMinPixel)*gainUnitsPerPixel - viewPortBottomEdge*(get<1>(plotExtentPoint)-get<1>(plotOriginPoint))*gainUnitsPerPixel;
        newPhaseAxisMin = currentPhaseAxisMin + (get<1>(plotExtentPoint) - zoomYMaxPixel)*phaseUnitsPerPixel - viewPortBottomEdge*(get<1>(plotExtentPoint)-get<1>(plotOriginPoint))*phaseUnitsPerPixel;
        newPhaseAxisMax = currentPhaseAxisMin + (get<1>(plotExtentPoint) - zoomYMinPixel)*phaseUnitsPerPixel - viewPortBottomEdge*(get<1>(plotExtentPoint)-get<1>(plotOriginPoint))*phaseUnitsPerPixel;
    
        // Clip values to not be beyond current plot axes
        newFreqAxisMin = max(newFreqAxisMin, currentFreqAxisMin);
        newFreqAxisMax = min(newFreqAxisMax, currentFreqAxisMax);
        newGainAxisMin = max(newGainAxisMin, currentGainAxisMin);
        newGainAxisMax = min(newGainAxisMax, currentGainAxisMax);
        newPhaseAxisMin = max(newPhaseAxisMin, currentPhaseAxisMin);
        newPhaseAxisMax = min(newPhaseAxisMax, currentPhaseAxisMax);

        // Check to see if the zoom rectangle is totally outside the viewport
        if (newFreqAxisMin > currentFreqAxisMax || newFreqAxisMax < currentFreqAxisMin ||
            newGainAxisMin > currentGainAxisMax || newGainAxisMax < currentGainAxisMin ||
            newPhaseAxisMin > currentPhaseAxisMax || newPhaseAxisMax < currentPhaseAxisMin)
        {
            retVal = false;
        }
        // Check to make sure we're not excessively zoomed; PLPlot may not handle it well
        else if (fabs(newFreqAxisMax-newFreqAxisMin) < 1e-6 ||
                 fabs(newGainAxisMax-newGainAxisMin) < 1e-6 ||
                 fabs(newPhaseAxisMax-newPhaseAxisMin) < 1e-6)
        {
            retVal = false;
        }                 
        else
        {
            currentFreqAxisMin = newFreqAxisMin;
            currentFreqAxisMax = newFreqAxisMax;
            currentGainAxisMin = newGainAxisMin;
            currentGainAxisMax = newGainAxisMax;
            currentPhaseAxisMin = newPhaseAxisMin;
            currentPhaseAxisMax = newPhaseAxisMax;
            PlotFRA();
            zoomStack.push(make_tuple(make_tuple(false, currentFreqAxisMin, currentFreqAxisMax), 
                                      make_tuple(false, currentGainAxisMin, currentGainAxisMax), 
                                      make_tuple(false, currentPhaseAxisMin, currentPhaseAxisMax)));

            currentPlotSettings.freqAxisScale = make_tuple( false, pow(10.0, currentFreqAxisMin), pow(10.0, currentFreqAxisMax) );
            currentPlotSettings.gainAxisScale = make_tuple( false, currentGainAxisMin, currentGainAxisMax );
            currentPlotSettings.phaseAxisScale = make_tuple( false, currentPhaseAxisMin, currentPhaseAxisMax );

            retVal = true;
        }
    }
  
    plotDataAvailable = true;
    return retVal;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name: FRAPlotter::UndoOneZoom
//
// Purpose: Replot the FRA plot with the previous zoom settings.
//
// Parameters: [out] return: whether the undo zoom could be performed
//
// Notes: Returns false if there are no previous settings.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

bool FRAPlotter::UndoOneZoom(void)
{
    bool retVal = false;
    plotDataAvailable = false; // Will remain false if an exception is thrown

    if (zoomStack.size() == 1)
    {
        retVal = false;
    }
    else
    {
        // Pop one set of axis values off the stack
        tuple<tuple<bool,double,double>,tuple<bool,double,double>,tuple<bool,double,double>> newAxes;
        zoomStack.pop();
        newAxes = zoomStack.top();

        currentFreqAxisMin = get<1>(get<0>(newAxes));
        currentFreqAxisMax = get<2>(get<0>(newAxes));
        currentGainAxisMin = get<1>(get<1>(newAxes));
        currentGainAxisMax = get<2>(get<1>(newAxes));
        currentPhaseAxisMin = get<1>(get<2>(newAxes));
        currentPhaseAxisMax = get<2>(get<2>(newAxes));

        currentPlotSettings.freqAxisScale = make_tuple( get<0>(get<0>(newAxes)), pow(10.0, currentFreqAxisMin), pow(10.0, currentFreqAxisMax) );
        currentPlotSettings.gainAxisScale = make_tuple( get<0>(get<1>(newAxes)), currentGainAxisMin, currentGainAxisMax );
        currentPlotSettings.phaseAxisScale = make_tuple( get<0>(get<2>(newAxes)), currentPhaseAxisMin, currentPhaseAxisMax );
        
        PlotFRA();

        retVal = true;
    }

    plotDataAvailable = true;
    return retVal;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name: FRAPlotter::ZoomToOriginal
//
// Purpose: Replot the FRA plot with the original zoom settings (undo all zooms).
//
// Parameters: [out] return: false if we're already at the original zoom setting and no re-plotting
//                           occurred.
//
// Notes: N/A
//
///////////////////////////////////////////////////////////////////////////////////////////////////

bool FRAPlotter::ZoomToOriginal(void)
{
    bool retVal = false;
    plotDataAvailable = false; // Will remain false if an exception is thrown

    if (zoomStack.size() == 1) // We're already at the original
    {
        retVal = false;
    }
    else
    {
        // Get to the base the stack
        while (zoomStack.size() > 1) 
        {
            zoomStack.pop();
        }

        tuple<tuple<bool,double,double>,tuple<bool,double,double>,tuple<bool,double,double>> newAxes;
        newAxes = zoomStack.top();

        currentFreqAxisMin = get<1>(get<0>(newAxes));
        currentFreqAxisMax = get<2>(get<0>(newAxes));
        currentGainAxisMin = get<1>(get<1>(newAxes));
        currentGainAxisMax = get<2>(get<1>(newAxes));
        currentPhaseAxisMin = get<1>(get<2>(newAxes));
        currentPhaseAxisMax = get<2>(get<2>(newAxes));

        currentPlotSettings.freqAxisScale = make_tuple( get<0>(get<0>(newAxes)), pow(10.0, currentFreqAxisMin), pow(10.0, currentFreqAxisMax) );
        currentPlotSettings.gainAxisScale = make_tuple( get<0>(get<1>(newAxes)), currentGainAxisMin, currentGainAxisMax );
        currentPlotSettings.phaseAxisScale = make_tuple( get<0>(get<2>(newAxes)), currentPhaseAxisMin, currentPhaseAxisMax );
        
        PlotFRA();

        retVal = true;
    }

    plotDataAvailable = true;
    return retVal;
    
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name: FRAPlotter::PlotDataAvailable
//
// Purpose: Indicate whether the plot pixel buffer has plot data.
//
// Parameters: [out] return: true if the plot pixel buffer has plot data, false otherwise
//
// Notes: N/A
//
///////////////////////////////////////////////////////////////////////////////////////////////////

bool FRAPlotter::PlotDataAvailable(void)
{
    return plotDataAvailable;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name: FRAPlotter::GetPlotSettings
//
// Purpose: Gets the current plot axis scale and interval settings.
//
// Parameters: [out] plotSettings: the current slot settings
//
// Notes: N/A
//
///////////////////////////////////////////////////////////////////////////////////////////////////

void FRAPlotter::GetPlotSettings(PlotSettings_T& plotSettings)
{
    plotSettings = currentPlotSettings;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name: FRAPlotter::GetScreenBitmapPlot32BppBGRA
//
// Purpose: This function implements/hides the transformation of the PLPlot buffer to a format 
//          compatible with the UI.  This could be mem (24bpp RGB), memcairo (32bpp RGBA) to 
//          WinGDI (32bpp BGRA) or something else.
//
// Parameters: [out] return: a unique pointer to the converted buffer
//
// Notes: Actual work is carried out by worker thread of this object.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

unique_ptr<uint8_t[]> FRAPlotter::GetScreenBitmapPlot32BppBGRA(void)
{
    DWORD dwWaitResult;
    unique_ptr<uint8_t[]> buffer;

    buffer = unique_ptr<uint8_t[]>(new uint8_t[plotWidth*plotHeight*4]);

    cmd = CMD_MAKE_SCREEN_BITMAP_32BPP_BGRA;
    cmdResult = indeterminate;
    workingBuffer = buffer.get();
    SetEvent(hFraPlotterExecuteCommandEvent);
    dwWaitResult = WaitForSingleObject( hFraPlotterCommandCompleteEvent, INFINITE );

    if (dwWaitResult == WAIT_OBJECT_0)
    {
        return move(buffer);
    }
    else
    {
        throw runtime_error("Application Error: Invalid wait result in GetScreenBitmapPlot32BppBGRA");
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name: FRAPlotter::GetPNGBitmapPlot
//
// Purpose: Create a PNG file from the plot most recently generated.
//
// Parameters: [out] return: a unique pointer to the PNG buffer
//
// Notes:  Actual work is carried out by worker thread of this object.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

unique_ptr<uint8_t[]> FRAPlotter::GetPNGBitmapPlot(size_t* size)
{
    DWORD dwWaitResult;

    cmd = CMD_MAKE_FILE_BITMAP_PNG;
    cmdResult = indeterminate;
    SetEvent(hFraPlotterExecuteCommandEvent);
    dwWaitResult = WaitForSingleObject( hFraPlotterCommandCompleteEvent, INFINITE );

    if (dwWaitResult == WAIT_OBJECT_0)
    {
        if (cmdResult == true)
        {
            *size = workingBufferSize;
        }
        else
        {
            *size = 0;
        }
        unique_ptr<uint8_t[]> buffer(workingBuffer);
        return move(buffer);
    }
    else
    {
        throw runtime_error("Application Error: Invalid wait result in GetPNGBitmapPlot");
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Name: FRAPlotter::WorkerThread
//
// Purpose: A thread function performing the services of the object.
//
// Parameters: [in] lpThreadParameter - Parameter to pass to the thread on creation.  In this case
//                                      it's used to pass the object instance pointer.
//
// Notes: This function uses the Windows Imaging Component (WIC)
//
///////////////////////////////////////////////////////////////////////////////////////////////////

DWORD WINAPI FRAPlotter::WorkerThread(LPVOID lpThreadParameter)
{
    static bool initSucceeded = true;
    HRESULT hr;
    DWORD dwWaitResult;
    FRAPlotter* instance = (FRAPlotter*)lpThreadParameter;
    IWICImagingFactory     *pIWICFactory = NULL;
    IWICBitmap             *pPlotBitmap24RGB;

    // Initialize Com
    if(FAILED(hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED)))
    {
        initSucceeded = false;
    }
    // Create WIC factory
    if (FAILED(hr = CoCreateInstance( CLSID_WICImagingFactory, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&pIWICFactory))))
    {
        initSucceeded = false;
    }

    for (;;)
    {
        dwWaitResult = WaitForSingleObject( instance->hFraPlotterExecuteCommandEvent, INFINITE );

        if (dwWaitResult == WAIT_OBJECT_0)
        {
            // If we don't have a valid WIC Factory, signal failure and reset;
            if (initSucceeded == false)
            {
                instance->cmdResult = false;
                SetEvent(instance->hFraPlotterCommandCompleteEvent);
                continue;
            }

            // Decode the command
            if (instance->cmd == CMD_MAKE_SCREEN_BITMAP_32BPP_BGRA)
            {
                IWICBitmapSource       *pPlotBitmap32BGRA;

                if (FAILED(hr = pIWICFactory -> CreateBitmapFromMemory( instance->plotWidth, instance->plotHeight, GUID_WICPixelFormat24bppRGB,
                                (instance->bytesPerPixel)*(instance->plotWidth),
                                (instance->plotWidth)*(instance->plotHeight)*(instance->bytesPerPixel),
                                instance->plotBmBuffer.data(), &pPlotBitmap24RGB)))
                {
                    instance->cmdResult = false;
                }
                // Convert to a GDI compatible format (32BPP BGRA)
                else if (FAILED(hr = WICConvertBitmapSource( GUID_WICPixelFormat32bppBGRA, pPlotBitmap24RGB, &pPlotBitmap32BGRA)))
                {
                    instance->cmdResult = false;
                }
                else if (FAILED(hr = pPlotBitmap32BGRA->CopyPixels( 0, instance->plotWidth*4, (instance->plotWidth)*(instance->plotHeight)*4, instance->workingBuffer)))
                {
                    instance->cmdResult = false;
                }
                else
                {
                    instance->cmdResult = true;
                }

                SafeRelease(&pPlotBitmap24RGB);
                SafeRelease(&pPlotBitmap32BGRA);

                SetEvent(instance->hFraPlotterCommandCompleteEvent);
            }
            else if (instance->cmd == CMD_MAKE_FILE_BITMAP_PNG)
            {
                IStream* pIStream = NULL;
                IWICStream *pIWICStream = NULL;
                IWICBitmapEncoder *pEncoder = NULL;
                IWICBitmapFrameEncode *pFrameEncode = NULL;
                WICPixelFormatGUID format = GUID_WICPixelFormat32bppPBGRA;

                if (FAILED(hr = CreateStreamOnHGlobal( NULL, TRUE, &pIStream )))
                {
                    instance->cmdResult = false;
                }
                else if (FAILED(hr = pIWICFactory->CreateStream(&pIWICStream)))
                {
                    instance->cmdResult = false;
                }
                else if (FAILED(hr = pIWICStream->InitializeFromIStream(pIStream)))
                {
                    instance->cmdResult = false;
                }
                else if (FAILED(hr = pIWICFactory->CreateEncoder(GUID_ContainerFormatPng, NULL, &pEncoder)))
                {
                    instance->cmdResult = false;
                }
                else if (FAILED(hr = pEncoder->Initialize(pIWICStream, WICBitmapEncoderNoCache)))
                {
                    instance->cmdResult = false;
                }
                else if (FAILED(hr = pEncoder->CreateNewFrame(&pFrameEncode, NULL)))
                {
                    instance->cmdResult = false;
                }
                else if (FAILED(hr = pFrameEncode->Initialize(NULL)))
                {
                    instance->cmdResult = false;
                }
                else if (FAILED(hr = pFrameEncode->SetSize(instance->plotWidth, instance->plotHeight)))
                {
                    instance->cmdResult = false;
                }
                else if (FAILED(hr = pFrameEncode->SetPixelFormat(&format)))
                {
                    instance->cmdResult = false;
                }
                else if (FAILED(hr = pIWICFactory -> CreateBitmapFromMemory( instance->plotWidth, instance->plotHeight, GUID_WICPixelFormat24bppRGB,
                                     (instance->bytesPerPixel)*(instance->plotWidth),
                                     (instance->plotWidth)*(instance->plotHeight)*(instance->bytesPerPixel),
                                     instance->plotBmBuffer.data(), &pPlotBitmap24RGB)))
                {
                    instance->cmdResult = false;
                }

                else if (FAILED(hr = pFrameEncode->WriteSource(pPlotBitmap24RGB, NULL)))
                {
                    instance->cmdResult = false;
                }
                else if (FAILED(hr = pFrameEncode->Commit()))
                {
                    instance->cmdResult = false;
                }
                else if (FAILED(hr = pEncoder->Commit()))
                {
                    instance->cmdResult = false;
                }
                else
                {
                    LARGE_INTEGER li = {0};
                    STATSTG statStg;
                    if (FAILED(hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL)))
                    {
                        instance->cmdResult = false;
                    }
                    else if (FAILED(hr = pIStream->Stat( &statStg, STATFLAG_NONAME )))
                    {
                        instance->cmdResult = false;
                    }
                    else
                    {
                        instance->workingBuffer = new uint8_t[statStg.cbSize.LowPart];

                        if (FAILED(hr = pIStream->Read(instance->workingBuffer, statStg.cbSize.LowPart, NULL)))
                        {
                            instance->cmdResult = false;
                        }
                        else
                        {
                            instance->workingBufferSize = statStg.cbSize.LowPart;
                            instance->cmdResult = true;
                        }
                    }
                }

                SafeRelease(&pIStream);
                SafeRelease(&pIWICStream);
                SafeRelease(&pEncoder);
                SafeRelease(&pFrameEncode);
                SafeRelease(&pPlotBitmap24RGB);

                SetEvent(instance->hFraPlotterCommandCompleteEvent);
            }
            else if (instance->cmd == CMD_EXIT)
            {
                break;
            }
        }
        else
        {
            instance->cmdResult = false;
            SetEvent(instance->hFraPlotterCommandCompleteEvent);
        }
    }

    SafeRelease(&pIWICFactory);

    SetEvent(instance->hFraPlotterCommandCompleteEvent);

    return 0;
}

int FRAPlotter::HandlePLplotError(const char* error)
{
    string plplotErrorString = "PLplot error: ";
    plplotErrorString += error;
    plend();
    throw runtime_error( plplotErrorString.c_str() );
}

// Setup the viewport to take up +/- 15% horizontal and +/- 10% vertical
const double FRAPlotter::viewPortLeftEdge = 0.15;
const double FRAPlotter::viewPortRightEdge = 0.85;
const double FRAPlotter::viewPortBottomEdge = 0.1;
const double FRAPlotter::viewPortTopEdge = 0.9;